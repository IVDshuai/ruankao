# 软考-软件设计师（75+75）

## 上午

### 数据结构与算法基础（10分）

- 数据结构基础与线性表

  - 基本概念

    - 数据：描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合
    - 数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录
    - 数据项：一个数据元素可以由若干个数据项组成，是数据不可分割的最小单位

      - DB的属性

    - 数据对象：是性质相同的数据元素的集合，是数据的子集
    - 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合
    - 逻辑结构：是指数据对象中数据元素之间的相互关系

      - 集合结构

        - 其中的元素除了同属于一个集合外，没有其他关系

      - 线性结构

        - 元素之间是一对一的关系

      - 树形结构

        - 元素之间存在一对多的层次关系

      - 图形结构

        - 元素之间多对多

          - 将每个数据元素看做一个结点，用圆圈表示
          - 若是有向的，加箭头即可

    - 物理结构：指数据的逻辑结构在计算机中的存储形式

      - 顺序存储结构：把数据元素放在地址连续的存储单元里
      - 链式存储结构：把数据元素存放在任意的存储单元里，这组存储单元可以是连续的，也可以是不连续的

    - 数据类型：指一组性质相同的值的集合，和定义在此集合上的一些操作的总称

      - 原子类型：不可再分解的类型，int、string等
      - 结构类型：数组、结构体等

- 广义表

  - 线性表

    - 零个或多个数据元素的有限序列

      - 例如：小学生放学后排队出校门

    - 线性表长度：表中元素的个数n，当n=0时，称为空表
    - 点名册也算一种线性表
    - 线性表中的元素必须是相同类型的数据
    - 顺序存储结构

      - 地址：存储器中每个存储单元的编号
      - 线性表的局限：由于线性表中可以进行插入和删除操作，因此分配的数组空间要大于等于当前线性表的长度
      - 获得
      - 插入

        - 算法思路

          - 1、如果插入的位置不合理，抛出异常
          - 2、如果线性表长度大于等于数据长度，则抛出异常或动态增加容量
          - 3、从最后一个元素开始向前遍历到第i个位置，分别将他们都向后移动一个位置
          - 4、将要插入的元素填入位置i处
          - 5、表长+1

      - 删除

        - 算法思路

          - 1、如果删除位置不合理，抛出异常
          - 2、取出删除元素
          - 3、从删除元素位置开始遍历到最后一个元素位置，分别将他们都向前移动一个位置
          - 4、表长-1

      - 特点

        - 优点

          - 无需为表示表中元素之间的逻辑关系而增加额外的存储空间
          - 可以快速存取表中任一位置的元素

        - 缺点

          - 插入和删除操作需要移动大量元素
          - 当线性表长度变化较大时，难以确定存储空间的容量
          - 造成存储空间的“碎片”

    - 链式存储结构

      - 每个数据元素除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）

        - 数据域
        - 指针域

      - 指针域中存储的信息成为指针或链
      - 数据域+指针域组成数据元素ai的存储映像，成为节点（Node）
      - 头指针：链表中第一个节点的存储位置

        - 无论链表是否为空，头指针均不为空，它是链表的必要元素

      - 头节点：单链表中的第一个结点前附设一个结点，即头结点

        - 指针域存储指向第一个结点的指针
        - 数据域可以不存储任何东西，也可以存储表的长度等信息
        - 不是链表的必要元素

      - 读取

        - 算法思路（获得链表中第i个数据）

          - 1、声明一个结点p指向链表第一个结点，初始化j从1开始
          - 2、当j<i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1
          - 3、若到链表末尾p为空，则说明第i个元素不存在
          - 4、否则查找成功，返回结点p的数据

      - 插入

        - 算法思路（单链表第i个数据插入结点，数据元素为e）

          - 1、先找到第i个元素p（读取p）
          - 2、在系统中生成一个空结点s
          - 3、将元素e赋值给s->data
          - 4、单链表的插入标准语句：s->next=p->next;  p->next=s;

      - 删除

        - 算法思路（单链表第i个数据删除结点）

          - 1、先找到第i个元素p（读取p）
          - 2、将欲删除的结点p->next赋值给q
          - 3、单链表的删除标准语句p->next=q->next
          - 4、将q结点中的数据赋值给e，作为返回
          - 5、释放q结点

            - C语言中，free()函数可以让系统回收一个Node结点，释放内存

      - 整表创建

        - 1、声明一个结点p和计数器变量i
        - 2、初始化一空链表L
        - 3、让L的头结点的指针指向NULL，即建立一个带头结点的单链表
        - 4、循环

          - 插队法，即始终让新结点在第一的位置，又叫头插法
          - 1、生成一个新结点赋值给p
          - 2、随机生成一数字赋值给p的数据域p->data
          - 3、将p插入到头结点与前一新结点之间
          - 除了以上的方法之外，还有尾插法

      - 整表删除

        - 1、声明一结点p和q
        - 2、将第一个结点赋值给p
        - 3、循环

          - 1、将下一个结点赋值给q
          - 2、释放p  free(p);
          - 3、将q赋值给p

    - 优缺点

      - 若线性表需要频繁查询，很少进行插入和删除操作，顺序存储结构更合适

        - 游戏开发中的用户注册

      - 反之单链表结构更合适

        - 玩家的装备列表

    - 静态链表：由数组描述的链表，使用数据下标做next指针

      - 优点

        - 在插入和删除操作时，只需要修改游标，不用移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点

      - 缺点

        - 没有解决林旭存储分配带来的表长难以确定的问题
        - 失去了顺序存储结构随机存取的特性

    - 循环链表：单链表中终端结点的指针改为指向头结点，使得整个单链表形成一个环
    - 双向链表：在单链表的每个结点中再设置指向前面结点的指针域

- 栈与队列

  - 栈

    - 下标为0的一端作为栈底
    - 先进后出
    - 两栈共享空间

      - 两个栈从一个数组两端开始，向中间靠拢

    - 栈的链式存储结构（简称链栈）

      - 把栈顶放在单链表的头部

    - 顺序栈与链栈的区分

      - 1、若使用过程中元素变化不可预料，时大时小，最好用链栈
      - 2、如果栈的变化在可控范围之内，最好使用顺序栈

    - 应用

      - 递归（递归函数：直接调用自己或通过一系列的调用语句间接调用自己的函数）

        - 斐波那契数列

          - 假如兔子不死，且两个月大后，每月生出一对小兔子，一年后可以繁殖多少对兔子（1，1，2，3，5，8，13）
          - 前面相邻两项之和，构成了后一项

        - 后缀表示法（逆波兰表示法）

          - 所有的负号都是在要运算数字的后面出现
          - 规则

            - 从左到右遍历表达式的每个数字和符号
            - 遇到是数字就进栈
            - 遇到的是符号，就将处于栈顶的两个数字出站，进行运算，运算结果进栈
            - 循环上述操作

          - 中缀表达式（标准的四则运算）转后缀表达式

            - 从左到右遍历标准表达式中的每个数字和符号，若是数字就输出，若是符号，则判断其与栈顶符号的优先级，是右括号或优先级低于栈顶符号则栈顶元素依次出栈并输出，并将当前符号进栈，一直到最终输出后缀表达式为止

  - 队列

    - 队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表
    - 先进先出（FIFO），允许插入的一端称为队尾，允许删除的一端称为队头
    - 循环队列

      - 头尾相接

- 串（字符串）

  - 串的顺序存储有不同，串值的存储空间可在程序执行的过程中动态分配而得
  - 串的链式存储结构除了在连接串与串操作时有一定方便之外，总的来说不如顺序存储灵活，性能也比不上
  - KMP模式匹配算法

- 树

  - 定义：是n个结点的有限集

    - 在任意一棵非空树中

      - 有且仅有一个特定的根节点
      - 当n>1时，其余结点可分为m(m>0)个互不相交的有限集T1\T2\T3....,其中每个集合又是一个树，并称为根的子树

  - 度：结点拥有的子树称为结点的度
  - 结点分类

    - 根节点
    - 内部节点
    - 终端结点

      - 度为0

  - 结点的层次

    - 根为第一层
    - 树中结点的最大层次称为树的深度或高度

  - 有序树

    - 树中结点的各子树看成从左至右有次序的，不能互换

  - 树的存储结构

    - 双亲表示法：在每个结点中，附设一个指示器指示其双亲结点到链表中的位置
    - 孩子表示法：每个结点有多个指针域，其中每个指针指向一棵子树的根结点

  - 二叉树

    - 特点

      - 每个结点最多有两棵树
      - 左子树与右子树是有顺序的，次序不能任意颠倒
      - 即使树种某结点只有一棵树，也要区分是左子树还是右子树

    - 基本形态

      - 空二叉树
      - 只有一个根结点
      - 根结点只有左子树
      - 根结点只有右子树
      - 根节点既有左子树又有右子树

    - 特殊形态

      - 斜树

        - 左斜
        - 右斜

      - 满二叉树

        - 大圆满

      - 完全二叉树：对一棵具有n个结点的二叉树按层序编号，如果编号为i的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树成为完全二叉树

        - 特点

          - 叶子结点只能出现在最下两层
          - 最下层的叶子一定集中在左部连续位置
          - 倒数二层，如果有叶子结点，一定都在右部连续位置
          - 如果结点度为1，则该结点只有左孩子
          - 同样结点数的二叉树，完全二叉树的深度最小

    - 性质

      - 1、在二叉树的第i层上，最多有2^(i-1)个结点
      - 2、深度为k的二叉树最多有2^k-1个结点
      - 3、对于任何二叉树T，若其终端结点个数为n0，度为2的结点数为n2，则n0=n2+1
      - 4、具有n个结点的完全二叉树的深度为[log(2n)]+1
      - 5、若对于一棵有n个结点的完全二叉树····

    - 存储结构

      - 顺序存储

        - 一般只用于完全二叉树，其他的树，空间利用率太低

      - 二叉链表

        - 左子，数据，右子

    - 遍历二叉树：从根结点出发，按照某种次序依次访问二叉树中的所有结点，是的每个结点被访问一次，且仅被访问一次

      - 前序遍历
      - 中序遍历
      - 后序遍历
      - 层序遍历

    - 线索二叉树：直线前驱和后继的指针叫做线索，加上线索额的二叉链表称为线索链表，相应的二叉树成为线索二叉树

      - 对二叉树以某种次序遍历，使其变为线索二叉树的过程称作是线索化
      - 优点

        - 方便遍历
        - 方便查找节点时遍历序列中的前驱和后继

    - 树转二叉树

      - 1、加线，在所有兄弟结点之间加一条连线
      - 2、去线，对树中每个结点，只保留其与第一个孩子结点的连线，删除其他连线
      - 3、层次调整，以树的根结点为轴心，将整棵树顺时针旋转一定角度，使之结构层次分明

    - 森林转二叉树
    - 赫夫曼树

      - 从树中的一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上分枝数目称作路径长度
      - 树的路径长度：从树根到每个结点的路径长度之和
      - 赫夫曼树：加权路径长度WPL最小的二叉树
      - 赫夫曼编码

- 图

  - 定义：是由定点的有穷非空集合和定点之间边的集合组成，通常表示为：G(V,E),其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合
  - 区分点

    - 线性表中的数据元素叫元素；树中的数据元素叫结点；图中的数据元素叫顶点
    - 图不允许为空（没有顶点）
    - 图中任意两个顶点之间都可能有关系，顶点之间的逻辑关系用边来表示，边集可以是空的

  - 无向边

    - 若图中任意两个顶点之间的边都是无向边，则成为无向图

  - 有向边，又叫弧

    - 若图中任意两个顶点之间的边都是有向边，则称该图为有向图

  - 无向边使用（）表示，有向边使用<>表示
  - 无向完全图

    - 任意两个顶点之间都存在边的无向图

  - 有向完全图

    - 任意两个顶点之间都存在方向互反的两条弧的有向图

  - 稀疏图与稠密图
  - 网

    - 带权的图

  - 图与子图
  - 顶点与边之间的关系

    - 边依附于顶点
    - 顶点的度是和该顶点相关联的边的数量
    - 对于有向图，有出度和入度
    - 无向图中，顶点A到顶点B的路径是一个顶点序列
    - 有向图中A到B有路径，但是B到A不一定有路径

  - 连通图

    - 无向图中，如果从顶点A到顶点B有路径，称A和B是连通的，若图中任意两个顶点都是联通的，则该图为连通图
    - 无向图中的极大连通子图称为连通分量

      - 子图
      - 子图要连通
      - 连通子图含有极大定点数
      - 具有极大顶点数的连通子图包含依附于这些顶点的所有边

    - 有向图中，对每一对顶点，都存在路径，则称之为强连通图

      - 有向图中的极大强连通子图称作有向图的强连通分量

  - 关于树与图

    - 无向图中连通且n个顶点n-1条边叫生成树
    - 有向图中顶点入度为0其余顶点入度为1的叫有向树
    - 一个有向图由若干棵有向树构成生成森林

  - 247

- 查找与排序
- 算法基础知识

  - 定义：是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作
  - 算法特性

    - 输入输出

      - 零个或多个输入
      - 至少有一个输出

    - 有穷性

      - 执行有限的步骤，并且每个步骤在可接受的时间内完成

    - 确定性

      - 算法的每一步都具有确定的含义，不会出现二义性

    - 可行性

      - 每一步都能通过执行有限次数完成

  - 算法设计要求

    - 正确性
    - 可读性
    - 健壮性
    - 时间效率高和存储量低

- 算法策略
- 时间复杂度和空间复杂度

  - 算法的度量方法

    - 事后统计法

      - 不科学、不准确

    - 事前分析估算法

  - 时间复杂度

    - 常数阶
    - 线性阶
    - 对数阶
    - 平方阶

### 程序语言与语言处理程序（6分）

### 操作系统（6分）

### 软件工程（11分）

- 软件生命周期
- 软件开发模型
- 软件开发方法论
- 软件测试
- 软件维护
- 软件质量管理
- 软件过程改进
- 软件项目管理

  - pert图

### 面向对象方法（12分）

- 面向对象基础

  - 类的分类

    - 边界类

      - 描述系统外部环境和系统内部运作之间的交互

    - 抽象类

      - 也叫控制类
      - 描述特定用例的控制行为

    - 实体类

      - 主要职责是存储和管理系统内部的信息
      - 也可以有很复杂的行为
      - 独立于系统外部环境
      - 类比数据库DB

  - 类之间的关系

    - 依赖关系
    - 泛化关系

      - 继承关系

    - 组合关系
    - 聚合关系
    - 实现关系

- 面向对象分析与设计

  - 设计原则

    - 里氏替换原则

      - 派生类（子类）对象可以在程式中代替其基类（超类）对象

        - 不应该在代码中出现if/else之类对派生类类型进行判断的条件。
        - 派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。
        - 子类可以扩展父类的功能，但不能改变父类原有的功能。

          - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
          - 子类中可以增加自己特有的方法。
          - 当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。
          - 当子类的方法实现父类的方法时（重载/重写或实现抽象方法）的后置条件（即方法的输出/返回值）要比父类更严格或相等。

    - 单一职责原则

      - 永远不要让一个类存在多个改变的理由。

    - 开闭原则

      - 软件实体（模块，类，方法等）应该对扩展开放，对修改关闭。

    - 依赖倒置原则

      - A. 高层模块不应该依赖于低层模块，二者都应该依赖于抽象
      - B. 抽象不应该依赖于细节，细节应该依赖于抽象
      - C.针对接口编程，不要针对实现编程。

    - 接口隔离原则

      - 不能强迫用户去依赖那些他们不使用的接口。

    - 组合重用原则

      - 尽量使用组合/聚合，不要使用类继承。
      - 聚合表示整体和部分的关系，表示“拥有”。
      - 组合则是一种更强的“拥有”，部分和整体的生命周期一样。

    - 迪米特原则

      - 类对于其他类知道的越少越好
      - 迪米特原则要求类“羞涩”一点，尽量不要对外公布太多的public方法和非静态的public变量，尽量内敛，多使用private、protected等访问权限。

  - 面向对象的分析

    - 建模系统功能
    - 发现并确定业务对象
    - 组织对象并确定期关系

  - 面向对象设计

    - 设计各个对象之间的关系

      - 层次关系
      - 继承关系

    - 设计各个对象之间的通信方式

      - 消息模式
      - ···

- UML基础

  - 5大系统视图

    - 逻辑视图

      - 即设计视图，表示设计模型中在架构方面具有重要意义的部分，即：类、子系统、包、用例实现的子集

    - 进程视图

      - 是可执行线程和进程作为活动类的建模
      - 是逻辑视图的一次执行实例，描述了并发与同步结构

    - 实现视图

      - 对组成基于系统的物理代码的文件和构建进行建模

        - 应该就是代码文件树

    - 部署视图

      - 把构建部署到一组物理节点上，表示软件到硬件的映射和分布结构

    - 用例视图

      - 是最基本的需求分析模型

  - 序列图

    - 是一种交互图，描述了系统中对象之间传递消息的时间次序

  - 用例之间的关系

    - 包含关系

      - 当可以从两个或两个以上的用例中提取公共行为时，应该使用包含关系来表示他们
      - 提取出来的公共用例称为抽象用例，原始用例称为基础用例
      - 特征：被抽象出来的用例是基础用例不可或缺的一部分

    - 扩展关系

      - 如果一个用例明显地混合了两种或两种以上的不同场景，则可以将这个用例分为一个基本用例和多个扩展用例
      - 目的：使描述更加清晰
      - 特征：抽取的用例对于基础用例来说是非必须的

    - 泛化关系

      - 当多个用例共同拥有一种类似的结构和行为时，可以将它们的共性抽象为父用例，其他用例作为子用例
      - 特征：子用例是父用例的一种特殊形式，子用例继承了父用例的所有结构、行为和关系

  - UML图

    - 结构性视图

      - 类图
      - 对象图
      - 包图
      - 组合结构图
      - 构件图
      - 部署图
      - 制品图

    - 行为性视图

      - 用例图
      - 顺序图
      - 通信图
      - 定时图
      - 交互概览图
      - 状态图

        - 状态机

      - 活动图

- 面向对象程序设计语言

### 计算机硬件基础（6分）

### 数据库系统（6分）

### 计算机网络（5分）

### 信息安全（3分）

### 多媒体技术（3分）

### 法律法规与标准化（2分）

## 下午

### 数据流图（模糊，但是下午试题一15分，必答）

- 填空
- 找错

### 数据库分析与设计（模糊，但是下午试题一15分，必答）

- 从需求分析到概念设计、逻辑设计
- ER图
- 关系模式
- 主键外键
- 规范化理论
- 增加实体信息

### UML建模（模糊，但是下午试题一15分，必答）

- 抠图填空

  - 类名、活动名、状态名

- 13种常见的UML图
- 类图是重点
- 用例图
- 难度较大

### 数据结构与算法应用（模糊，但是下午试题一15分，必答）

### C语言算法

- C语言填空，8分

  - C语法
  - 赋值语句
  - for循环判断条件

- 算法策略、时间复杂度，7分

  - 算法策略选择

    - 分治法
    - 贪心法
    - 动态规划法
    - 回溯法

  - 时间复杂度，不用计算，会判断规模

### 面向对象程序设计（15分，C++和java二选一）

- 代码填空

  - 5-7个空
  - 每个空填写一个语句
  - 基础语法填空+逻辑填空

- 设计模式

### 技巧

- 多看题干

## 上午分数分布

### 共45道题，75个空，每空1分

### 及格：45分

## 下午分数分布

### 6道大题，每题15分

### 第五第六任选一道

